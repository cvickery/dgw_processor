#! /usr/local/bin/python3
""" This is like dgw_processor.py, only different.
    Instead of walking the tree and triggering callbacks. explore the structure of the tree.
"""
import os
import re
import sys
import argparse
import pickle
import resource
import traceback

from enum import IntEnum

from ReqBlockLexer import ReqBlockLexer
from ReqBlockParser import ReqBlockParser
from ReqBlockVisitor import ReqBlockVisitor

from antlr4 import *
from antlr4.error.ErrorListener import ErrorListener

from dgw_filter import dgw_filter
from pgconnection import PgConnection
from psycopg2 import Binary

from dgw_handlers import dispatch
from dgw_utils import build_course_list,\
    catalog_years,\
    class_name,\
    class_or_credit,\
    colleges,\
    context_path,\
    expression_terminals,\
    get_number

DEBUG = os.getenv('DEBUG_PROCESSOR')
LOG_CONTEXT_PATH = os.getenv('LOG_CONTEXT_PATH')

# resource.setrlimit(resource.RLIMIT_STACK, ((resource.RLIM_INFINITY, resource.RLIM_INFINITY)))
sys.setrecursionlimit(10**6)

# # class ScribeSection(IntEnum)
# # -------------------------------------------------------------------------------------------------
# class ScribeSection(IntEnum):
#   """ Keep track of which section of a Scribe Block is being processed.
#   """
#   NONE = 0
#   HEAD = 1
#   BODY = 2


# # Class DGW_Processor(ReqBlockVisitor)
# # =================================================================================================
# # The ReqBlockVisitor module is generated by Antlr4 from the grammar in ReqBlock.g4. This class
# # provides the method overrides for the stubs provided in ReqBlockVisitor.
# class DGW_Processor(ReqBlockVisitor):
#   def __init__(self,
#                institution,
#                requirement_id,
#                block_type,
#                block_value,
#                title,
#                period_start,
#                period_stop,
#                requirement_text):
#     """ Constructor, given metadata and text for a requirement block.
#     """

#     if LOG_CONTEXT_PATH:
#       print(f'*** DGW_Processor: {institution} {requirement_id} {block_type} “{title}”',
#             file=sys.stderr)
#     self.institution = institution
#     self.requirement_id = requirement_id
#     self.block_type = block_type
#     self.block_type_str = (block_type.lower()
#                            .replace('conc', 'concentration')
#                            .replace('other', 'other requirement'))
#     self.block_value = block_value
#     self.title = title
#     self.catalog_years = catalog_years(period_start, period_stop)
#     self.period_stop = period_stop
#     self.institution_name = colleges[institution]
#     self.requirement_text = requirement_text
#     self.scribe_section = ScribeSection.NONE
#     self.sections = [None, [], []]  # NONE, HEAD, BODY

#     def visitReq_block(self, ctx: ReqBlockParser.Req_blockContext):
#       print(f'visitReq_block {ctx=}')
#       return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#head.
#     def visitHead(self, ctx: ReqBlockParser.HeadContext):
#       print(f'visitHead {ctx=}')
#       return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#body.
#     def visitBody(self, ctx: ReqBlockParser.BodyContext):
#       print(f'visitBody {ctx=}')
#       return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#course_list.
#     def visitCourse_list(self, ctx: ReqBlockParser.Course_listContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#course_list_head.
#     def visitCourse_list_head(self, ctx: ReqBlockParser.Course_list_headContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#course_list_qualifier_head.
#     def visitCourse_list_qualifier_head(self, ctx: ReqBlockParser.Course_list_qualifier_headContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#course_list_body.
#     def visitCourse_list_body(self, ctx: ReqBlockParser.Course_list_bodyContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#course_list_qualifier_body.
#     def visitCourse_list_qualifier_body(self, ctx: ReqBlockParser.Course_list_qualifier_bodyContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#full_course.
#     def visitFull_course(self, ctx: ReqBlockParser.Full_courseContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#course_item.
#     def visitCourse_item(self, ctx: ReqBlockParser.Course_itemContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#and_list.
#     def visitAnd_list(self, ctx: ReqBlockParser.And_listContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#or_list.
#     def visitOr_list(self, ctx: ReqBlockParser.Or_listContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#catalog_number.
#     def visitCatalog_number(self, ctx: ReqBlockParser.Catalog_numberContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#discipline.
#     def visitDiscipline(self, ctx: ReqBlockParser.DisciplineContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#if_then.
#     def visitIf_then(self, ctx: ReqBlockParser.If_thenContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#else_clause.
#     def visitElse_clause(self, ctx: ReqBlockParser.Else_clauseContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#stmt_group.
#     def visitStmt_group(self, ctx: ReqBlockParser.Stmt_groupContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#stmt.
#     def visitStmt(self, ctx: ReqBlockParser.StmtContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#begin_if.
#     def visitBegin_if(self, ctx: ReqBlockParser.Begin_ifContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#end_if.
#     def visitEnd_if(self, ctx: ReqBlockParser.End_ifContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#group.
#     def visitGroup(self, ctx: ReqBlockParser.GroupContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#group_list.
#     def visitGroup_list(self, ctx: ReqBlockParser.Group_listContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#group_item.
#     def visitGroup_item(self, ctx: ReqBlockParser.Group_itemContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#group_qualifier.
#     def visitGroup_qualifier(self, ctx: ReqBlockParser.Group_qualifierContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#subset.
#     def visitSubset(self, ctx: ReqBlockParser.SubsetContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#subset_qualifier.
#     def visitSubset_qualifier(self, ctx: ReqBlockParser.Subset_qualifierContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#block.
#     def visitBlock(self, ctx: ReqBlockParser.BlockContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#blocktype.
#     def visitBlocktype(self, ctx: ReqBlockParser.BlocktypeContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#allow_clause.
#     def visitAllow_clause(self, ctx: ReqBlockParser.Allow_clauseContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#class_credit_head.
#     def visitClass_credit_head(self, ctx: ReqBlockParser.Class_credit_headContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#class_credit_body.
#     def visitClass_credit_body(self, ctx: ReqBlockParser.Class_credit_bodyContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#copy_rules.
#     def visitCopy_rules(self, ctx: ReqBlockParser.Copy_rulesContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#display.
#     def visitDisplay(self, ctx: ReqBlockParser.DisplayContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#except_list.
#     def visitExcept_list(self, ctx: ReqBlockParser.Except_listContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#including_list.
#     def visitIncluding_list(self, ctx: ReqBlockParser.Including_listContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#label.
#     def visitLabel(self, ctx: ReqBlockParser.LabelContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#lastres.
#     def visitLastres(self, ctx: ReqBlockParser.LastresContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#maxclass.
#     def visitMaxclass(self, ctx: ReqBlockParser.MaxclassContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#maxcredit.
#     def visitMaxcredit(self, ctx: ReqBlockParser.MaxcreditContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#maxpassfail.
#     def visitMaxpassfail(self, ctx: ReqBlockParser.MaxpassfailContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#maxperdisc.
#     def visitMaxperdisc(self, ctx: ReqBlockParser.MaxperdiscContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#maxspread.
#     def visitMaxspread(self, ctx: ReqBlockParser.MaxspreadContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#maxterm.
#     def visitMaxterm(self, ctx: ReqBlockParser.MaxtermContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#maxtransfer.
#     def visitMaxtransfer(self, ctx: ReqBlockParser.MaxtransferContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#minarea.
#     def visitMinarea(self, ctx: ReqBlockParser.MinareaContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#minclass.
#     def visitMinclass(self, ctx: ReqBlockParser.MinclassContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#mincredit.
#     def visitMincredit(self, ctx: ReqBlockParser.MincreditContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#mingpa.
#     def visitMingpa(self, ctx: ReqBlockParser.MingpaContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#mingrade.
#     def visitMingrade(self, ctx: ReqBlockParser.MingradeContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#minperdisc.
#     def visitMinperdisc(self, ctx: ReqBlockParser.MinperdiscContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#minres.
#     def visitMinres(self, ctx: ReqBlockParser.MinresContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#minspread.
#     def visitMinspread(self, ctx: ReqBlockParser.MinspreadContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#minterm.
#     def visitMinterm(self, ctx: ReqBlockParser.MintermContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#noncourse.
#     def visitNoncourse(self, ctx: ReqBlockParser.NoncourseContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#optional.
#     def visitOptional(self, ctx: ReqBlockParser.OptionalContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#remark.
#     def visitRemark(self, ctx: ReqBlockParser.RemarkContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#rule_complete.
#     def visitRule_complete(self, ctx: ReqBlockParser.Rule_completeContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#ruletag.
#     def visitRuletag(self, ctx: ReqBlockParser.RuletagContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#samedisc.
#     def visitSamedisc(self, ctx: ReqBlockParser.SamediscContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#share.
#     def visitShare(self, ctx: ReqBlockParser.ShareContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#standalone.
#     def visitStandalone(self, ctx: ReqBlockParser.StandaloneContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#string.
#     def visitString(self, ctx: ReqBlockParser.StringContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#symbol.
#     def visitSymbol(self, ctx: ReqBlockParser.SymbolContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#tag.
#     def visitTag(self, ctx: ReqBlockParser.TagContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#under.
#     def visitUnder(self, ctx: ReqBlockParser.UnderContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#with_clause.
#     def visitWith_clause(self, ctx: ReqBlockParser.With_clauseContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#expression.
#     def visitExpression(self, ctx: ReqBlockParser.ExpressionContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#logical_op.
#     def visitLogical_op(self, ctx: ReqBlockParser.Logical_opContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#relational_op.
#     def visitRelational_op(self, ctx: ReqBlockParser.Relational_opContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#list_or.
#     def visitList_or(self, ctx: ReqBlockParser.List_orContext):
#         return self.visitChildren(ctx)

#     # Visit a parse tree produced by ReqBlockParser#list_and.
#     def visitList_and(self, ctx: ReqBlockParser.List_andContext):
#         return self.visitChildren(ctx)


# dgw_parser()
# =================================================================================================
def dgw_parser(institution, block_type, block_value, period='all'):
  """ For each matching Scribe Block, create a DGW_Processor to hold the info about it; the
      constructor parses the block and extracts information objects from it, creating a HTML
      representation of the Scribe Block and lists of dicts of the extracted objects, one for the
      head and one for the body of the block.

      Update/replace the HTML Scribe Block and the lists of object in the requirement_blocks table.

       The period argument can be 'current', 'latest', or 'all', which will be picked out of the
       result set for 'all'
  """
  if DEBUG:
    print(f'*** dgw_parser({institution}, {block_type}, {block_value}. {period})', file=sys.stderr)

  conn = PgConnection()
  fetch_cursor = conn.cursor()
  update_cursor = conn.cursor()
  query = """
    select requirement_id, title, period_start, period_stop, requirement_text
    from requirement_blocks
    where institution = %s
      and block_type = %s
      and block_value = %s
    order by period_stop desc
  """
  fetch_cursor.execute(query, (institution, block_type, block_value))
  # Sanity Check
  assert fetch_cursor.rowcount > 0, f'No Requirements Found\n{fetch_cursor.query}'
  num_rows = fetch_cursor.rowcount
  num_updates = 0
  for row in fetch_cursor.fetchall():
    print(f'{institution} {row.requirement_id} {block_type} {block_value} {row.title}')
    if period == 'current' and row.period_stop != '99999999':
      return f"""<h1 class="error">“{row.title}” is not a currently offered {block_type}
                 at {institution}.</h1>
              """
    # Filter out everything after END.
    # For parsing, also filter out "hide" things, but leave them in for display purposes.
    text_to_parse = dgw_filter(row.requirement_text)
    text_to_show = dgw_filter(row.requirement_text, remove_hide=False)
    # processor = DGW_Processor(institution,
    #                           row.requirement_id,
    #                           block_type,
    #                           block_value,
    #                           row.title,
    #                           row.period_start,
    #                           row.period_stop,
    #                           text_to_show)

    # Default behavior is just to show the scribe block(s), and not to try parsing them in real
    # time. (But during development, that can be useful for catching coding errors.)

    # dgw_logger = DGW_Logger(institution, block_type, block_value, row.period_stop)

    input_stream = InputStream(text_to_parse)
    lexer = ReqBlockLexer(input_stream)
    # lexer.removeErrorListeners()
    # lexer.addErrorListener(dgw_logger)
    token_stream = CommonTokenStream(lexer)
    parser = ReqBlockParser(token_stream)
    # parser.removeErrorListeners()
    # parser.addErrorListener(dgw_logger)
    tree = parser.req_block()

    head_ctx = tree.head()
    if head_ctx:
      for child in head_ctx.getChildren():
        obj = dispatch(child, 'head')
        if obj != {}:
          print(f'{institution} {row.requirement_id} Head:  {class_name(child)}', file=sys.stderr)
          print(obj, file=sys.stderr)
    body_ctx = tree.body()
    if body_ctx:
      for child in body_ctx.getChildren():
        obj = dispatch(child, 'body')
        if obj != {}:
          print(f'{institution} {row.requirement_id} Body:  {class_name(child)}', file=sys.stderr)
          print(obj, file=sys.stderr)

    if period == 'current' or period == 'latest':
      break
  conn.commit()
  conn.close()
  if DEBUG:
    print()
  return (num_updates, num_rows)


# __main__
# =================================================================================================
# Create DGW_Processor objects for testing
if __name__ == '__main__':
  """ You can parse a block or a list of blocks from here.
      But if you just want to update the html for the blocks you select, omit the --parse option
  """
  # Command line args
  parser = argparse.ArgumentParser(description='Test DGW Parser')
  parser.add_argument('-d', '--debug', action='store_true', default=False)
  parser.add_argument('-f', '--format')
  parser.add_argument('-i', '--institutions', nargs='*', default=['QNS01'])
  parser.add_argument('-t', '--block_types', nargs='+', default=['MAJOR'])
  parser.add_argument('-v', '--block_values', nargs='+', default=['CSCI-BS'])

  # Parse args
  args = parser.parse_args()

  if args.institutions[0] == 'all':
    conn = PgConnection()
    cursor = conn.cursor()
    cursor.execute('select code from cuny_institutions')
    institutions = [row.code for row in cursor.fetchall()]
    conn.close()
  else:
    institutions = args.institutions

  num_institutions = len(institutions)
  institution_count = 0
  for institution in institutions:
    institution_count += 1
    institution = institution.upper() + ('01' * (len(institution) == 3))
    if args.block_types[0] == 'all':
      args.block_types = ['DEGREE', 'MAJOR', 'MINOR', 'CONC', 'OTHER']
    types_count = 0
    num_types = len(args.block_types)
    for block_type in args.block_types:
      types_count += 1
      if args.block_values[0] == 'all':
        conn = PgConnection()
        cursor = conn.cursor()
        cursor.execute('select distinct block_value from requirement_blocks '
                       'where institution = %s and block_type = %s'
                       'order by block_value', (institution, block_type))
        block_values = [row.block_value for row in cursor.fetchall()]
        conn.close()
      else:
        block_values = args.block_values

      num_values = len(block_values)
      values_count = 0
      for block_value in block_values:
        values_count += 1
        if block_value.isnumeric() or block_value.startswith('MHC'):
          # print(f'Skipping {institution} {block_type} {block_value}')
          continue
        print(f'{institution_count} / {num_institutions}; {types_count} / {num_types}; '
              f'{values_count} / {num_values}', end='')
        num_updates, num_blocks = dgw_parser(institution,
                                             block_type.upper(),
                                             block_value,
                                             period='latest')
        suffix = '' if num_updates == 1 else 's'
        # print(f'{operation} {num_updates} block{suffix} for {institution} {block_type} '
        #       f'{block_value}')
