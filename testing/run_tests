#! /usr/local/bin/bash

# Clean out the test_results directory.
# Parse all requirement blocks in the test_data directory.
# Capture error messages in the test_results directory.
#  Empty result files indicate complete parsing with no errors.

dirs=()
while [[ $# > 0 ]]
do
  dirs+=($1)
  shift
done
if [[ ${#dirs[@]} == 0 ]]
then
  dirs=(major minor degree conc other)
fi

SECONDS=0

if [[ ${#dirs[@]} == 5 ]]
then
      echo -e 'Type\tBlock\tLines\tMessages\tSeconds' > run_tests.csv
fi

let $((total = 0))
for dir in ${dirs[@]}
do
  block_type=${dir##*.}
  if [[ ${#dirs[@]} == 5 ]]
  then suffix=''
  else  suffix=".$dir"
        echo -e 'Type\tBlock\tLines\tMessages\tSeconds' > run_tests${suffix}.csv
  fi

  block_str=`echo $block_type|tr a-z A-Z`
  rm -fr test_results.$block_type
  mkdir test_results.$block_type
  num_files=`ls test_data.$block_type|wc -l`
  echo -e "\nThere are $num_files $block_str files"
  let count=0
  for file in test_data.$block_type/*
  do
    [[ $DEBUG ]] && echo  -e "$count/$num_files\t$file"
    let $((count = count + 1))
    ./run.py $block_type ${file#*/} >> run_tests${suffix}.csv 2>> timeouts.log
    echo -en "               \r$count/$num_files\r"
  done
  num_errors=`ls test_results.$block_type|wc -l`
  echo -e "\n$block_str completed after $SECONDS seconds with $num_errors errors."
  let $(( total += $SECONDS ))
  SECONDS=0
done
./count_results.py
let $((mins = total/60))
let $((secs = total - (mins * 60) ))
printf "%02d:%02d total time" $mins $secs
